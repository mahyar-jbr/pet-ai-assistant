"""
Pet AI Assistant - FastAPI Backend
Main application entry point

This file contains:
- FastAPI app setup and CORS configuration
- MongoDB database connection
- Pydantic models for request/response validation
- CRUD endpoints for pets and products
- Recommendation engine with scoring algorithm

Run with: uvicorn main:app --reload --port 8000
API docs: http://localhost:8000/docs
"""

# ============================================
# Imports
# ============================================

from fastapi import FastAPI, HTTPException          # Web framework and HTTP error handling
from fastapi.middleware.cors import CORSMiddleware  # Allow cross-origin requests (frontend ‚Üí backend)
from motor.motor_asyncio import AsyncIOMotorClient  # Async MongoDB driver (non-blocking DB calls)
from pydantic import BaseModel, Field               # Data validation and schema definition
from typing import List, Optional                   # Type hints for better code clarity
from bson import ObjectId                           # MongoDB's unique ID type
import os                                           # Access environment variables

# ============================================
# FastAPI Application Setup
# ============================================

# Create the FastAPI app instance
# - title/description/version appear in auto-generated docs at /docs
app = FastAPI(
    title="Pet AI Assistant API",
    description="Backend API for pet food recommendations",
    version="2.0.0"
)

# ============================================
# CORS Configuration (Cross-Origin Resource Sharing)
# ============================================

# CORS allows the frontend (localhost:5173) to call the backend (localhost:8000)
# Without this, browsers block cross-origin requests for security

# WARNING: Allowing all origins ("*") is insecure for production! Remember to restrict this.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],        # Who can call this API ("*" = anyone, use specific domains in production)
    allow_credentials=True,     # Allow cookies and authorization headers
    allow_methods=["*"],        # Allow all HTTP methods (GET, POST, PUT, DELETE, etc.)
    allow_headers=["*"],        # Allow all headers
)

# ============================================
# MongoDB Connection
# ============================================

# Get MongoDB URL from environment variable, or use localhost as default
# This allows different URLs for development vs production
MONGODB_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DATABASE_NAME = "petai"

# Create async MongoDB client (Motor = async wrapper around PyMongo)
client = AsyncIOMotorClient(MONGODB_URL)

# Get references to database and collections
# This is like running "use petai" then "db.pets" in mongosh
database = client[DATABASE_NAME]
pets_collection = database["pets"]          # Stores pet profiles
products_collection = database["products"]  # Stores dog food products

# ============================================
# Pydantic Models (Request/Response Schemas)
# ============================================

# Pydantic models define the SHAPE of data and validate it automatically
# - If data doesn't match the schema, FastAPI returns a 422 error
# - Two models per resource: one for INPUT (Create), one for OUTPUT (Response)


class PetCreate(BaseModel):
    """
    Schema for creating a new pet profile.
    Used when: POST /api/pets

    All fields except allergies are required.
    This model validates data BEFORE it reaches your endpoint code.
    """
    name: str                               # Pet's name (required)
    breedSize: str                          # "small", "medium", or "large" (required)
    ageGroup: str                           # "puppy", "adult", or "senior" (required)
    activityLevel: str                      # "low", "medium", or "high" (required)
    weightGoal: str                         # "maintenance", "weight-loss", or "muscle-gain" (required)
    allergies: Optional[List[str]] = []     # List of allergens, defaults to empty list


class PetResponse(BaseModel):
    """
    Schema for returning pet data to the frontend.
    Used when: GET /api/pets, POST /api/pets response

    Includes 'id' field which is generated by MongoDB.
    """
    id: str                                 # MongoDB ObjectId converted to string
    name: str
    breedSize: str
    ageGroup: str
    activityLevel: str
    weightGoal: str
    allergies: List[str]
    breed: Optional[str] = Field(
        default=None,
        description="Deprecated legacy field - prefer breedSize"
    )


class ProductCreate(BaseModel):
    """
    Schema for creating/importing a dog food product.
    Used when: Importing products from scrapers or CSV

    Contains all nutritional information, pricing, and metadata.
    Optional fields use None as default for products with missing data.
    """
    # === Required Fields ===
    id: str                             # Unique product ID (e.g., "Orijen-Large-Breed-Adult")
    brand: str                          # Brand name (e.g., "Orijen", "Royal Canin")
    line: str                           # Product line name (e.g., "Large Breed Adult Recipe")
    format: str                         # "dry", "wet", or "raw"
    life_stage: str                     # "puppy", "adult", "senior", or "all"
    breed_size: str                     # "small", "medium", "large", or "all"
    primary_proteins: str               # Comma-separated (e.g., "Chicken, Turkey, Salmon")
    grain_free: bool                    # True if no grains in ingredients
    ingredients: str                    # Full ingredient list as text
    allergen_tags: str                  # Comma-separated allergens (e.g., "chicken, fish, eggs")
    tags: str                           # Comma-separated tags for filtering

    # === Nutritional Information (Guaranteed Analysis) ===
    # All percentages, all optional since not all products have complete data
    protein_pct: Optional[float] = None             # Crude protein %
    fat_pct: Optional[float] = None                 # Crude fat %
    ash_pct: Optional[float] = None                 # Ash content %
    fiber_pct: Optional[float] = None               # Crude fiber %
    moisture_pct: Optional[float] = None            # Moisture %
    calcium_pct: Optional[float] = None             # Calcium %
    phosphorus_pct: Optional[float] = None          # Phosphorus %
    omega_6_fatty_acids: Optional[float] = None     # Omega-6 %
    omega_3_fatty_acids: Optional[float] = None     # Omega-3 %
    DHA: Optional[float] = None                     # DHA % (brain health)
    EPA: Optional[float] = None                     # EPA % (joint health)

    # === Calorie Information ===
    kcal_per_cup: Optional[int] = None              # Calories per cup
    kcal_per_kg: Optional[int] = None               # Calories per kg

    # === Product Details ===
    kibble_size: Optional[str] = None               # "small", "regular", or "large"
    size_kg: Optional[float] = None                 # Package size in kg
    price: Optional[float] = None                   # Price in dollars
    price_per_kg: Optional[float] = None            # Calculated price per kg
    retailer: Optional[str] = None                  # Where to buy (e.g., "PetValu")
    image: Optional[str] = None                     # Product image URL
    source_url: Optional[str] = None                # Where data was scraped from
    updated_at: Optional[str] = None                # Last update timestamp


class ProductResponse(BaseModel):
    """
    Schema for returning product data to the frontend.
    Mirrors ProductCreate but used for API responses.
    """
    id: str
    brand: str
    line: str
    format: str
    life_stage: str
    breed_size: str
    primary_proteins: str
    grain_free: bool
    ingredients: str
    allergen_tags: str
    protein_pct: Optional[float] = None
    fat_pct: Optional[float] = None
    ash_pct: Optional[float] = None
    fiber_pct: Optional[float] = None
    moisture_pct: Optional[float] = None
    calcium_pct: Optional[float] = None
    phosphorus_pct: Optional[float] = None
    omega_6_fatty_acids: Optional[float] = None
    omega_3_fatty_acids: Optional[float] = None
    DHA: Optional[float] = None
    EPA: Optional[float] = None
    kcal_per_cup: Optional[int] = None
    kcal_per_kg: Optional[int] = None
    kibble_size: Optional[str] = None
    tags: str
    size_kg: Optional[float] = None
    price: Optional[float] = None
    price_per_kg: Optional[float] = None
    retailer: Optional[str] = None
    image: Optional[str] = None
    source_url: Optional[str] = None
    updated_at: Optional[str] = None


# ============================================
# Helper Functions (MongoDB ‚Üí API conversion)
# ============================================

# These functions convert MongoDB documents to API response format.
# Why needed:
#   1. MongoDB uses "_id" (ObjectId type) ‚Üí API needs "id" (string)
#   2. MongoDB fields might be missing ‚Üí API needs default values
#   3. Centralizes conversion logic in one place


def pet_helper(pet) -> dict:
    """
    Convert a MongoDB pet document to API response format.

    MongoDB document:  {"_id": ObjectId("..."), "name": "Buddy", ...}
    API response:      {"id": "...", "name": "Buddy", ...}

    Uses .get() with defaults to handle missing fields gracefully.
    """
    # Handle legacy field name: old data might use "breed" instead of "breedSize"
    breed_size = pet.get("breedSize", pet.get("breed", ""))

    pet_data = {
        "id": str(pet["_id"]),                  # Convert ObjectId to string for JSON
        "name": pet.get("name", ""),            # .get() returns "" if field missing
        "breedSize": breed_size,
        "ageGroup": pet.get("ageGroup", ""),
        "activityLevel": pet.get("activityLevel", ""),
        "weightGoal": pet.get("weightGoal", ""),
        "allergies": pet.get("allergies", [])
    }

    # Include legacy "breed" field for backward compatibility with old frontend code
    if pet.get("breed") or breed_size:
        pet_data["breed"] = pet.get("breed", breed_size)

    return pet_data


def product_helper(product) -> dict:
    """
    Convert a MongoDB product document to API response format.

    Handles all product fields including nutritional data.
    - String fields: default to "" (empty string)
    - Number fields: default to None (will be null in JSON)
    - Boolean fields: default to False
    """
    return {
        # === Basic Info ===
        "id": str(product.get("_id", "")),
        "brand": product.get("brand", ""),
        "line": product.get("line", ""),
        "format": product.get("format", ""),
        "life_stage": product.get("life_stage", ""),
        "breed_size": product.get("breed_size", ""),
        "primary_proteins": product.get("primary_proteins", ""),
        "grain_free": product.get("grain_free", False),
        "ingredients": product.get("ingredients", ""),
        "allergen_tags": product.get("allergen_tags", ""),

        # === Nutritional Info (None if not available) ===
        "protein_pct": product.get("protein_pct"),
        "fat_pct": product.get("fat_pct"),
        "ash_pct": product.get("ash_pct"),
        "fiber_pct": product.get("fiber_pct"),
        "moisture_pct": product.get("moisture_pct"),
        "calcium_pct": product.get("calcium_pct"),
        "phosphorus_pct": product.get("phosphorus_pct"),
        "omega_6_fatty_acids": product.get("omega_6_fatty_acids"),
        "omega_3_fatty_acids": product.get("omega_3_fatty_acids"),
        "DHA": product.get("DHA"),
        "EPA": product.get("EPA"),

        # === Calorie Info ===
        "kcal_per_cup": product.get("kcal_per_cup"),
        "kcal_per_kg": product.get("kcal_per_kg"),

        # === Product Details ===
        "kibble_size": product.get("kibble_size", ""),
        "tags": product.get("tags", ""),
        "size_kg": product.get("size_kg"),
        "price": product.get("price"),
        "price_per_kg": product.get("price_per_kg"),
        "retailer": product.get("retailer", ""),
        "image": product.get("image", ""),
        "source_url": product.get("source_url", ""),
        "updated_at": product.get("updated_at", "")
    }


# ============================================
# Pet API Endpoints (CRUD Operations)
# ============================================

# CRUD = Create, Read, Update, Delete
# These endpoints handle all pet profile operations.
#
# Endpoint Pattern:
#   @app.METHOD("/path", response_model=Schema, status_code=CODE)
#   - METHOD: get, post, put, delete
#   - response_model: Pydantic model to validate response
#   - status_code: HTTP status code to return (default 200)


@app.get("/")
async def root():
    """
    Health check endpoint.

    Used to verify the API is running.
    Visit http://localhost:8000/ to see this response.
    """
    return {
        "status": "running",
        "message": "Pet AI Assistant API is up and running!",
        "version": "2.0.0"
    }


@app.post("/api/pets", response_model=PetResponse, status_code=201)
async def create_pet(pet: PetCreate):
    """
    Create a new pet profile.

    - Request body: PetCreate schema (validated automatically by FastAPI)
    - Returns: The created pet with its MongoDB-generated ID
    - Status: 201 Created on success

    Flow:
    1. Pydantic validates the incoming JSON ‚Üí PetCreate
    2. Convert to dict and insert into MongoDB
    3. Fetch the created document (now has _id)
    4. Convert to response format and return
    """
    try:
        # Convert Pydantic model to dict for MongoDB
        pet_dict = pet.model_dump()

        # Insert into MongoDB (returns InsertOneResult with inserted_id)
        result = await pets_collection.insert_one(pet_dict)

        # Fetch the created document to get the full object with _id
        created_pet = await pets_collection.find_one({"_id": result.inserted_id})

        if created_pet:
            return pet_helper(created_pet)
        else:
            raise HTTPException(status_code=500, detail="Failed to create pet")

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating pet: {str(e)}")


@app.get("/api/pets", response_model=List[PetResponse])
async def get_all_pets():
    """
    Retrieve all pet profiles.

    - Returns: List of all pets in the database
    - Status: 200 OK

    Note: Uses 'async for' because Motor returns an async cursor.
    """
    try:
        pets = []
        # Async iteration over MongoDB cursor
        async for pet in pets_collection.find():
            pets.append(pet_helper(pet))
        return pets

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving pets: {str(e)}")


@app.get("/api/pets/{pet_id}", response_model=PetResponse)
async def get_pet_by_id(pet_id: str):
    """
    Retrieve a specific pet by ID.

    - Path parameter: pet_id (the MongoDB ObjectId as string)
    - Returns: The pet if found
    - Status: 200 OK, 404 if not found, 400 if invalid ID format

    Example: GET /api/pets/507f1f77bcf86cd799439011
    """
    try:
        # Validate that pet_id is a valid ObjectId format (24 hex characters)
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Query MongoDB (convert string to ObjectId for query)
        pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})

        if pet:
            return pet_helper(pet)
        else:
            raise HTTPException(status_code=404, detail="Pet not found")

    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is (don't convert to 500)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving pet: {str(e)}")


@app.put("/api/pets/{pet_id}", response_model=PetResponse)
async def update_pet(pet_id: str, pet: PetCreate):
    """
    Update an existing pet profile (full replacement).

    - Path parameter: pet_id
    - Request body: PetCreate schema with new data
    - Returns: The updated pet
    - Status: 200 OK, 404 if not found

    Note: PUT replaces all fields. For partial updates, use PATCH (not implemented).
    """
    try:
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Convert new data to dict
        pet_dict = pet.model_dump()

        # Update in MongoDB using $set operator
        # $set replaces only the specified fields (not the entire document)
        result = await pets_collection.update_one(
            {"_id": ObjectId(pet_id)},  # Filter: which document to update
            {"$set": pet_dict}           # Update: replace these fields
        )

        # Check if a document was found and updated
        if result.matched_count == 0:
            raise HTTPException(status_code=404, detail="Pet not found")

        # Fetch and return the updated document
        updated_pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})

        if updated_pet:
            return pet_helper(updated_pet)
        else:
            raise HTTPException(status_code=404, detail="Pet not found")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating pet: {str(e)}")


@app.delete("/api/pets/{pet_id}")
async def delete_pet(pet_id: str):
    """
    Delete a pet profile.

    - Path parameter: pet_id
    - Returns: Success message with deleted pet ID
    - Status: 200 OK, 404 if not found

    Note: No response_model because we return a custom message, not PetResponse.
    """
    try:
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Delete from MongoDB
        result = await pets_collection.delete_one({"_id": ObjectId(pet_id)})

        # Check if a document was actually deleted
        if result.deleted_count == 0:
            raise HTTPException(status_code=404, detail="Pet not found")

        return {"message": "Pet deleted successfully", "id": pet_id}

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting pet: {str(e)}")


# ============================================
# Product API Endpoints
# ============================================

# Products are read-only in this API (no create/update/delete).
# Products are imported via scrapers and import scripts, not the API.


@app.get("/api/products", response_model=List[ProductResponse])
async def get_all_products(
    life_stage: Optional[str] = None,
    breed_size: Optional[str] = None,
    grain_free: Optional[bool] = None,
    brand: Optional[str] = None,
    limit: Optional[int] = 100
):
    """
    Get all products with optional filtering.

    Query Parameters (all optional):
    - life_stage: "puppy", "adult", "senior", or "all"
    - breed_size: "small", "medium", "large", or "all"
    - grain_free: true or false
    - brand: Brand name (case-insensitive partial match)
    - limit: Max products to return (default 100)

    Example: GET /api/products?life_stage=adult&grain_free=true&limit=10

    The query is built dynamically based on which parameters are provided.
    """
    try:
        # Build MongoDB query dynamically
        query = {}

        if life_stage:
            query["life_stage"] = life_stage.lower()

        if breed_size:
            query["breed_size"] = breed_size.lower()

        # Note: Must check 'is not None' for booleans (False is a valid filter!)
        if grain_free is not None:
            query["grain_free"] = grain_free

        if brand:
            # $regex with $options:"i" = case-insensitive partial match
            # "orijen" matches "Orijen", "ORIJEN", etc.
            query["brand"] = {"$regex": brand, "$options": "i"}

        # Execute query with limit
        products = []
        async for product in products_collection.find(query).limit(limit):
            products.append(product_helper(product))

        return products

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving products: {str(e)}")


@app.get("/api/products/{product_id}", response_model=ProductResponse)
async def get_product_by_id(product_id: str):
    """
    Get a specific product by ID.

    - Path parameter: product_id (the product's unique string ID, NOT ObjectId)
    - Returns: The product if found
    - Status: 200 OK, 404 if not found

    Note: Product IDs are strings like "Orijen-Large-Breed-Adult", not ObjectIds.
    This is because products are imported with custom IDs, not auto-generated.
    """
    try:
        # Products use string IDs (not ObjectId), so query directly
        product = await products_collection.find_one({"_id": product_id})

        if product:
            return product_helper(product)
        else:
            raise HTTPException(status_code=404, detail="Product not found")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving product: {str(e)}")


# ============================================
# Recommendation Engine
# ============================================

class RecommendationResponse(BaseModel):
    """Response model for recommendations with score"""
    product: ProductResponse
    score: float
    match_percentage: int
    reasons: List[str]


def calculate_breed_size_score(pet_breed_size: str, product_kibble_size: str) -> tuple[float, str]:
    """
    Calculate breed size compatibility score

    Rules:
    - Small breed: small (+20) or regular (+15) kibble
    - Medium breed: regular (+20) kibble only
    - Large breed: large (+20) or regular (+15) kibble
    """
    pet_size = pet_breed_size.lower()
    kibble = product_kibble_size.lower()

    if pet_size == "small":
        if kibble == "small":
            return 20.0, "Perfect kibble size for small breed"
        elif kibble == "regular":
            return 15.0, "Compatible kibble size"
        else:
            return 0.0, ""

    elif pet_size == "medium":
        if kibble == "regular":
            return 20.0, "Perfect kibble size for medium breed"
        else:
            return 0.0, ""

    elif pet_size == "large":
        if kibble == "large":
            return 20.0, "Perfect kibble size for large breed"
        elif kibble == "regular":
            return 15.0, "Compatible kibble size"
        else:
            return 0.0, ""

    return 10.0, ""  # Fallback


def calculate_activity_goal_score(
    activity_level: str,
    weight_goal: str,
    protein_pct: float,
    fat_pct: float,
    fiber_pct: float
) -> tuple[float, List[str]]:
    """
    Calculate score based on activity level and dietary goals
    Max: 40 points
    """
    score = 0.0
    reasons = []
    activity = activity_level.lower()
    goal = weight_goal.lower()

    # High Activity Dogs
    if activity == "high":
        if goal == "muscle-gain":
            # Need high protein AND high fat
            if protein_pct >= 38:
                score += 20
                reasons.append("Excellent protein for muscle building")
            elif protein_pct >= 35:
                score += 15
                reasons.append("Good protein for active dogs")

            if fat_pct >= 15:
                score += 20
                reasons.append("High energy from fat for active lifestyle")
            elif fat_pct >= 12:
                score += 10

        elif goal == "maintenance":
            # Need high protein, moderate fat
            if protein_pct >= 35:
                score += 20
                reasons.append("Great protein for active dogs")
            elif protein_pct >= 30:
                score += 15

            if 12 <= fat_pct <= 18:
                score += 20
                reasons.append("Balanced fat for maintenance")
            elif fat_pct >= 15:
                score += 15

        elif goal == "weight-loss":
            # High protein, lower fat
            if protein_pct >= 35:
                score += 20
                reasons.append("High protein helps maintain muscle during weight loss")

            if fat_pct < 12 and fiber_pct >= 5:
                score += 20
                reasons.append("Lower fat and good fiber for weight management")
            elif fat_pct < 15:
                score += 10

    # Medium Activity Dogs
    elif activity == "medium":
        if goal == "maintenance":
            if 30 <= protein_pct <= 38:
                score += 20
                reasons.append("Balanced protein for moderate activity")
            elif protein_pct >= 28:
                score += 15

            if 12 <= fat_pct <= 18:
                score += 20
                reasons.append("Balanced fat for maintenance")

        elif goal == "muscle-gain":
            if protein_pct >= 35:
                score += 20
                reasons.append("Good protein for muscle building")

            if fat_pct >= 15:
                score += 15
                reasons.append("Adequate fat for energy")

        elif goal == "weight-loss":
            if protein_pct >= 30:
                score += 15

            if fat_pct < 12:
                score += 20
                reasons.append("Lower fat supports weight loss")
            elif fat_pct < 15:
                score += 10

    # Low Activity Dogs
    elif activity == "low":
        if goal == "weight-loss":
            if protein_pct >= 28:
                score += 15
                reasons.append("Adequate protein for less active dogs")

            if fat_pct < 12 and fiber_pct >= 5:
                score += 25
                reasons.append("Perfect for weight loss - low fat, high fiber")
            elif fat_pct < 12:
                score += 15

        elif goal == "maintenance":
            if 28 <= protein_pct <= 35:
                score += 20
                reasons.append("Balanced nutrition for less active dogs")

            if 10 <= fat_pct <= 15:
                score += 20
                reasons.append("Moderate fat prevents weight gain")

        elif goal == "muscle-gain":
            # Less common for low activity, but still score
            if protein_pct >= 35:
                score += 15
            if fat_pct >= 12:
                score += 10

    return min(score, 40.0), reasons


def calculate_nutritional_quality_score(
    protein_pct: float,
    fat_pct: float,
    omega_3: Optional[float],
    dha: Optional[float],
    epa: Optional[float],
    grain_free: bool
) -> tuple[float, List[str]]:
    """
    Calculate nutritional quality score
    Max: 25 points
    """
    score = 0.0
    reasons = []

    # Protein quality (0-10 points)
    if protein_pct >= 38:
        score += 10
        reasons.append("Premium protein content")
    elif protein_pct >= 35:
        score += 8
        reasons.append("High protein content")
    elif protein_pct >= 30:
        score += 5

    # Omega-3/DHA/EPA for joints and brain (0-5 points)
    if omega_3 and omega_3 >= 0.8:
        score += 3
        reasons.append("Excellent Omega-3 for joints and coat")
    elif omega_3 and omega_3 >= 0.5:
        score += 2

    if dha and dha >= 0.3:
        score += 2
        reasons.append("Good DHA for brain health")
    elif dha and dha >= 0.2:
        score += 1

    # Grain-free (0-5 points)
    if grain_free:
        score += 5
        reasons.append("Grain-free formula")

    # Fat quality (0-5 points)
    if 12 <= fat_pct <= 18:
        score += 5
        reasons.append("Balanced fat content")
    elif 10 <= fat_pct <= 20:
        score += 3

    return min(score, 25.0), reasons


def calculate_ingredient_quality_score(ingredients: str, primary_proteins: str) -> tuple[float, List[str]]:
    """
    Calculate ingredient quality score
    Max: 10 points
    """
    score = 0.0
    reasons = []

    ingredients_lower = ingredients.lower()

    # Fresh meat first ingredient (0-5 points)
    first_ingredients = ingredients_lower.split(',')[0:3]
    fresh_keywords = ['fresh', 'raw', 'whole']
    if any(keyword in ing for ing in first_ingredients for keyword in fresh_keywords):
        score += 5
        reasons.append("Fresh meat as primary ingredient")

    # Multiple protein sources (0-3 points)
    protein_count = len([p.strip() for p in primary_proteins.split(',') if p.strip()])
    if protein_count >= 3:
        score += 3
        reasons.append(f"Diverse protein sources ({protein_count} types)")
    elif protein_count >= 2:
        score += 2

    # No controversial ingredients (0-2 points)
    controversial = ['by-product', 'meal', 'digest', 'artificial']
    if not any(word in ingredients_lower for word in controversial):
        score += 2
        reasons.append("No controversial ingredients")

    return min(score, 10.0), reasons


def score_product_for_pet(product: dict, pet_profile: dict) -> tuple[float, List[str]]:
    """
    Calculate overall compatibility score for a product given a pet profile
    Returns: (score, reasons)
    """
    total_score = 0.0
    all_reasons = []

    # Extract pet info
    pet_breed_size = pet_profile.get("breedSize", "medium")
    pet_activity = pet_profile.get("activityLevel", "medium")
    pet_goal = pet_profile.get("weightGoal", "maintenance")
    pet_allergies = [a.lower().strip() for a in pet_profile.get("allergies", [])]

    # Extract product info
    product_kibble = product.get("kibble_size", "regular")
    protein_pct = product.get("protein_pct") or 0
    fat_pct = product.get("fat_pct") or 0
    fiber_pct = product.get("fiber_pct") or 0
    omega_3 = product.get("omega_3_fatty_acids")
    dha = product.get("DHA")
    epa = product.get("EPA")
    grain_free = product.get("grain_free", False)
    ingredients = product.get("ingredients", "")
    primary_proteins = product.get("primary_proteins", "")
    allergen_tags = product.get("allergen_tags", "")

    # HARD FILTER: Allergy check (return 0 if allergies present)
    product_allergens = [a.lower().strip() for a in allergen_tags.split(',') if a.strip()]
    if any(allergy in product_allergens for allergy in pet_allergies):
        return 0.0, ["Contains allergens - NOT RECOMMENDED"]

    # HARD FILTER: Kibble size incompatibility check
    pet_size = pet_breed_size.lower()
    kibble = product_kibble.lower()

    # Small dogs cannot eat large kibble
    if pet_size == "small" and kibble == "large":
        return 0.0, ["Kibble too large for small breed"]

    # Large dogs should not eat small kibble (choking hazard, not satisfying)
    if pet_size == "large" and kibble == "small":
        return 0.0, ["Kibble too small for large breed"]

    # Medium dogs should avoid small and large kibble
    if pet_size == "medium" and kibble in ["small", "large"]:
        return 0.0, ["Kibble size not suitable for medium breed"]

    # 1. Breed Size Score (0-20 points)
    breed_score, breed_reason = calculate_breed_size_score(pet_breed_size, product_kibble)
    total_score += breed_score
    if breed_reason:
        all_reasons.append(breed_reason)

    # 2. Activity + Goal Score (0-40 points)
    activity_score, activity_reasons = calculate_activity_goal_score(
        pet_activity, pet_goal, protein_pct, fat_pct, fiber_pct
    )
    total_score += activity_score
    all_reasons.extend(activity_reasons)

    # 3. Nutritional Quality Score (0-25 points)
    nutrition_score, nutrition_reasons = calculate_nutritional_quality_score(
        protein_pct, fat_pct, omega_3, dha, epa, grain_free
    )
    total_score += nutrition_score
    all_reasons.extend(nutrition_reasons)

    # 4. Ingredient Quality Score (0-10 points)
    ingredient_score, ingredient_reasons = calculate_ingredient_quality_score(
        ingredients, primary_proteins
    )
    total_score += ingredient_score
    all_reasons.extend(ingredient_reasons)

    # 5. Price Value Score (0-5 points) - TODO: Future implementation
    # For now, give baseline points
    total_score += 5

    return total_score, all_reasons


@app.get("/api/recommendations/{pet_id}")
async def get_recommendations(pet_id: str):
    """
    Get personalized dog food recommendations for a specific pet

    Returns top 15 products scored above 50 points, sorted by compatibility
    """
    try:
        # 1. Get pet profile
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})
        if not pet:
            raise HTTPException(status_code=404, detail="Pet not found")

        pet_profile = {
            "ageGroup": pet.get("ageGroup", "adult"),
            "breedSize": pet.get("breedSize", "medium"),
            "activityLevel": pet.get("activityLevel", "medium"),
            "weightGoal": pet.get("weightGoal", "maintenance"),
            "allergies": pet.get("allergies", [])
        }

        # 2. Get all products with hard filters
        query = {
            "format": "dry",  # Only dry food for now
        }

        # Life stage filter: match exact OR "all life stages"
        pet_age = pet_profile["ageGroup"].lower()
        query["$or"] = [
            {"life_stage": pet_age},
            {"life_stage": "all"}
        ]

        all_products = []
        async for product in products_collection.find(query):
            all_products.append(product)

        if not all_products:
            return {
                "pet": pet_profile,
                "recommendations": [],
                "message": "No products found matching basic criteria"
            }

        # 3. Score each product
        scored_products = []
        for product in all_products:
            score, reasons = score_product_for_pet(product, pet_profile)

            # Only include products scoring 50+
            if score >= 50:
                scored_products.append({
                    "product": product_helper(product),
                    "score": round(score, 1),
                    "match_percentage": int(score),  # 0-100 scale
                    "reasons": reasons[:3]  # Top 3 reasons
                })

        # 4. Sort by score (highest first) and limit to top 15
        scored_products.sort(key=lambda x: x["score"], reverse=True)
        top_recommendations = scored_products[:15]

        return {
            "pet": pet_profile,
            "total_matches": len(scored_products),
            "recommendations": top_recommendations
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating recommendations: {str(e)}")


# ============================================
# Application Lifecycle Events
# ============================================

@app.on_event("startup")
async def startup_event():
    """Run on application startup"""
    print("üöÄ Pet AI Assistant API starting up...")
    print(f"üìä Connected to MongoDB: {MONGODB_URL}")
    print(f"üóÑÔ∏è  Database: {DATABASE_NAME}")
    print("‚úÖ Ready to accept requests!")


@app.on_event("shutdown")
async def shutdown_event():
    """Run on application shutdown"""
    print("üëã Shutting down Pet AI Assistant API...")
    client.close()
    print("‚úÖ MongoDB connection closed")


# ============================================
# Run with: uvicorn main:app --reload --port 8080
# ============================================
