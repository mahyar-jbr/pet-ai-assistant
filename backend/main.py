"""
Pet AI Assistant - FastAPI Backend
Main application entry point

This file contains:
- FastAPI app setup and CORS configuration
- MongoDB database connection
- Pydantic models for request/response validation
- CRUD endpoints for pets and products
- Recommendation engine with scoring algorithm

Run with: uvicorn main:app --reload --port 8000
API docs: http://localhost:8000/docs
"""

# ============================================
# Imports
# ============================================

from fastapi import FastAPI, HTTPException          # Web framework and HTTP error handling
from fastapi.middleware.cors import CORSMiddleware  # Allow cross-origin requests (frontend → backend)
from motor.motor_asyncio import AsyncIOMotorClient  # Async MongoDB driver (non-blocking DB calls)
from pydantic import BaseModel, Field               # Data validation and schema definition
from typing import List, Optional                   # Type hints for better code clarity
from bson import ObjectId                           # MongoDB's unique ID type
import os                                           # Access environment variables

# ============================================
# FastAPI Application Setup
# ============================================

# Create the FastAPI app instance
# - title/description/version appear in auto-generated docs at /docs
app = FastAPI(
    title="Pet AI Assistant API",
    description="Backend API for pet food recommendations",
    version="2.0.0"
)

# ============================================
# CORS Configuration (Cross-Origin Resource Sharing)
# ============================================

# CORS allows the frontend (localhost:5173) to call the backend (localhost:8000)
# Without this, browsers block cross-origin requests for security

# WARNING: Allowing all origins ("*") is insecure for production! Remember to restrict this.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],        # Who can call this API ("*" = anyone, use specific domains in production)
    allow_credentials=True,     # Allow cookies and authorization headers
    allow_methods=["*"],        # Allow all HTTP methods (GET, POST, PUT, DELETE, etc.)
    allow_headers=["*"],        # Allow all headers
)

# ============================================
# MongoDB Connection
# ============================================

# Get MongoDB URL from environment variable, or use localhost as default
# This allows different URLs for development vs production
MONGODB_URL = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
DATABASE_NAME = "petai"

# Create async MongoDB client (Motor = async wrapper around PyMongo)
client = AsyncIOMotorClient(MONGODB_URL)

# Get references to database and collections
# This is like running "use petai" then "db.pets" in mongosh
database = client[DATABASE_NAME]
pets_collection = database["pets"]          # Stores pet profiles
products_collection = database["products"]  # Stores dog food products

# ============================================
# Pydantic Models (Request/Response Schemas)
# ============================================

# Pydantic models define the SHAPE of data and validate it automatically
# - If data doesn't match the schema, FastAPI returns a 422 error
# - Two models per resource: one for INPUT (Create), one for OUTPUT (Response)


class PetCreate(BaseModel):
    """
    Schema for creating a new pet profile.
    Used when: POST /api/pets

    All fields except allergies are required.
    This model validates data BEFORE it reaches your endpoint code.
    """
    name: str                               # Pet's name (required)
    breedSize: str                          # "small", "medium", or "large" (required)
    ageGroup: str                           # "puppy", "adult", or "senior" (required)
    activityLevel: str                      # "low", "medium", or "high" (required)
    weightGoal: str                         # "maintenance", "weight-loss", or "muscle-gain" (required)
    allergies: Optional[List[str]] = []     # List of allergens, defaults to empty list


class PetResponse(BaseModel):
    """
    Schema for returning pet data to the frontend.
    Used when: GET /api/pets, POST /api/pets response

    Includes 'id' field which is generated by MongoDB.
    """
    id: str                                 # MongoDB ObjectId converted to string
    name: str
    breedSize: str
    ageGroup: str
    activityLevel: str
    weightGoal: str
    allergies: List[str]
    breed: Optional[str] = Field(
        default=None,
        description="Deprecated legacy field - prefer breedSize"
    )


class ProductCreate(BaseModel):
    """
    Schema for creating/importing a dog food product.
    Used when: Importing products from scrapers or CSV

    Contains all nutritional information, pricing, and metadata.
    Optional fields use None as default for products with missing data.
    """
    # === Required Fields ===
    id: str                             # Unique product ID (e.g., "Orijen-Large-Breed-Adult")
    brand: str                          # Brand name (e.g., "Orijen", "Royal Canin")
    line: str                           # Product line name (e.g., "Large Breed Adult Recipe")
    format: str                         # "dry", "wet", or "raw"
    life_stage: str                     # "puppy", "adult", "senior", or "all"
    breed_size: str                     # "small", "medium", "large", or "all"
    primary_proteins: str               # Comma-separated (e.g., "Chicken, Turkey, Salmon")
    grain_free: bool                    # True if no grains in ingredients
    ingredients: str                    # Full ingredient list as text
    allergen_tags: str                  # Comma-separated allergens (e.g., "chicken, fish, eggs")
    tags: str                           # Comma-separated tags for filtering

    # === Nutritional Information (Guaranteed Analysis) ===
    # All percentages, all optional since not all products have complete data
    protein_pct: Optional[float] = None             # Crude protein %
    fat_pct: Optional[float] = None                 # Crude fat %
    ash_pct: Optional[float] = None                 # Ash content %
    fiber_pct: Optional[float] = None               # Crude fiber %
    moisture_pct: Optional[float] = None            # Moisture %
    calcium_pct: Optional[float] = None             # Calcium %
    phosphorus_pct: Optional[float] = None          # Phosphorus %
    omega_6_fatty_acids: Optional[float] = None     # Omega-6 %
    omega_3_fatty_acids: Optional[float] = None     # Omega-3 %
    DHA: Optional[float] = None                     # DHA % (brain health)
    EPA: Optional[float] = None                     # EPA % (joint health)

    # === Calorie Information ===
    kcal_per_cup: Optional[int] = None              # Calories per cup
    kcal_per_kg: Optional[int] = None               # Calories per kg

    # === Product Details ===
    kibble_size: Optional[str] = None               # "small", "regular", or "large"
    size_kg: Optional[float] = None                 # Package size in kg
    price: Optional[float] = None                   # Price in dollars
    price_per_kg: Optional[float] = None            # Calculated price per kg
    retailer: Optional[str] = None                  # Where to buy (e.g., "PetValu")
    image: Optional[str] = None                     # Product image URL
    source_url: Optional[str] = None                # Where data was scraped from
    updated_at: Optional[str] = None                # Last update timestamp


class ProductResponse(BaseModel):
    """
    Schema for returning product data to the frontend.
    Mirrors ProductCreate but used for API responses.
    """
    id: str
    brand: str
    line: str
    format: str
    life_stage: str
    breed_size: str
    primary_proteins: str
    grain_free: bool
    ingredients: str
    allergen_tags: str
    protein_pct: Optional[float] = None
    fat_pct: Optional[float] = None
    ash_pct: Optional[float] = None
    fiber_pct: Optional[float] = None
    moisture_pct: Optional[float] = None
    calcium_pct: Optional[float] = None
    phosphorus_pct: Optional[float] = None
    omega_6_fatty_acids: Optional[float] = None
    omega_3_fatty_acids: Optional[float] = None
    DHA: Optional[float] = None
    EPA: Optional[float] = None
    kcal_per_cup: Optional[int] = None
    kcal_per_kg: Optional[int] = None
    kibble_size: Optional[str] = None
    tags: str
    size_kg: Optional[float] = None
    price: Optional[float] = None
    price_per_kg: Optional[float] = None
    retailer: Optional[str] = None
    image: Optional[str] = None
    source_url: Optional[str] = None
    updated_at: Optional[str] = None


# ============================================
# Helper Functions (MongoDB → API conversion)
# ============================================

# These functions convert MongoDB documents to API response format.
# Why needed:
#   1. MongoDB uses "_id" (ObjectId type) → API needs "id" (string)
#   2. MongoDB fields might be missing → API needs default values
#   3. Centralizes conversion logic in one place


def pet_helper(pet) -> dict:
    """
    Convert a MongoDB pet document to API response format.

    MongoDB document:  {"_id": ObjectId("..."), "name": "Buddy", ...}
    API response:      {"id": "...", "name": "Buddy", ...}

    Uses .get() with defaults to handle missing fields gracefully.
    """
    # Handle legacy field name: old data might use "breed" instead of "breedSize"
    breed_size = pet.get("breedSize", pet.get("breed", ""))

    pet_data = {
        "id": str(pet["_id"]),                  # Convert ObjectId to string for JSON
        "name": pet.get("name", ""),            # .get() returns "" if field missing
        "breedSize": breed_size,
        "ageGroup": pet.get("ageGroup", ""),
        "activityLevel": pet.get("activityLevel", ""),
        "weightGoal": pet.get("weightGoal", ""),
        "allergies": pet.get("allergies", [])
    }

    # Include legacy "breed" field for backward compatibility with old frontend code
    if pet.get("breed") or breed_size:
        pet_data["breed"] = pet.get("breed", breed_size)

    return pet_data


def product_helper(product) -> dict:
    """
    Convert a MongoDB product document to API response format.

    Handles all product fields including nutritional data.
    - String fields: default to "" (empty string)
    - Number fields: default to None (will be null in JSON)
    - Boolean fields: default to False
    """
    return {
        # === Basic Info ===
        "id": str(product.get("_id", "")),
        "brand": product.get("brand", ""),
        "line": product.get("line", ""),
        "format": product.get("format", ""),
        "life_stage": product.get("life_stage", ""),
        "breed_size": product.get("breed_size", ""),
        "primary_proteins": product.get("primary_proteins", ""),
        "grain_free": product.get("grain_free", False),
        "ingredients": product.get("ingredients", ""),
        "allergen_tags": product.get("allergen_tags", ""),

        # === Nutritional Info (None if not available) ===
        "protein_pct": product.get("protein_pct"),
        "fat_pct": product.get("fat_pct"),
        "ash_pct": product.get("ash_pct"),
        "fiber_pct": product.get("fiber_pct"),
        "moisture_pct": product.get("moisture_pct"),
        "calcium_pct": product.get("calcium_pct"),
        "phosphorus_pct": product.get("phosphorus_pct"),
        "omega_6_fatty_acids": product.get("omega_6_fatty_acids"),
        "omega_3_fatty_acids": product.get("omega_3_fatty_acids"),
        "DHA": product.get("DHA"),
        "EPA": product.get("EPA"),

        # === Calorie Info ===
        "kcal_per_cup": product.get("kcal_per_cup"),
        "kcal_per_kg": product.get("kcal_per_kg"),

        # === Product Details ===
        "kibble_size": product.get("kibble_size", ""),
        "tags": product.get("tags", ""),
        "size_kg": product.get("size_kg"),
        "price": product.get("price"),
        "price_per_kg": product.get("price_per_kg"),
        "retailer": product.get("retailer", ""),
        "image": product.get("image", ""),
        "source_url": product.get("source_url", ""),
        "updated_at": product.get("updated_at", "")
    }


# ============================================
# Pet API Endpoints (CRUD Operations)
# ============================================

# CRUD = Create, Read, Update, Delete
# These endpoints handle all pet profile operations.
#
# Endpoint Pattern:
#   @app.METHOD("/path", response_model=Schema, status_code=CODE)
#   - METHOD: get, post, put, delete
#   - response_model: Pydantic model to validate response
#   - status_code: HTTP status code to return (default 200)


@app.get("/")
async def root():
    """
    Health check endpoint.

    Used to verify the API is running.
    Visit http://localhost:8000/ to see this response.
    """
    return {
        "status": "running",
        "message": "Pet AI Assistant API is up and running!",
        "version": "2.0.0"
    }


@app.post("/api/pets", response_model=PetResponse, status_code=201)
async def create_pet(pet: PetCreate):
    """
    Create a new pet profile.

    - Request body: PetCreate schema (validated automatically by FastAPI)
    - Returns: The created pet with its MongoDB-generated ID
    - Status: 201 Created on success

    Flow:
    1. Pydantic validates the incoming JSON → PetCreate
    2. Convert to dict and insert into MongoDB
    3. Fetch the created document (now has _id)
    4. Convert to response format and return
    """
    try:
        # Convert Pydantic model to dict for MongoDB
        pet_dict = pet.model_dump()

        # Insert into MongoDB (returns InsertOneResult with inserted_id)
        result = await pets_collection.insert_one(pet_dict)

        # Fetch the created document to get the full object with _id
        created_pet = await pets_collection.find_one({"_id": result.inserted_id})

        if created_pet:
            return pet_helper(created_pet)
        else:
            raise HTTPException(status_code=500, detail="Failed to create pet")

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating pet: {str(e)}")


@app.get("/api/pets", response_model=List[PetResponse])
async def get_all_pets():
    """
    Retrieve all pet profiles.

    - Returns: List of all pets in the database
    - Status: 200 OK

    Note: Uses 'async for' because Motor returns an async cursor.
    """
    try:
        pets = []
        # Async iteration over MongoDB cursor
        async for pet in pets_collection.find():
            pets.append(pet_helper(pet))
        return pets

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving pets: {str(e)}")


@app.get("/api/pets/{pet_id}", response_model=PetResponse)
async def get_pet_by_id(pet_id: str):
    """
    Retrieve a specific pet by ID.

    - Path parameter: pet_id (the MongoDB ObjectId as string)
    - Returns: The pet if found
    - Status: 200 OK, 404 if not found, 400 if invalid ID format

    Example: GET /api/pets/507f1f77bcf86cd799439011
    """
    try:
        # Validate that pet_id is a valid ObjectId format (24 hex characters)
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Query MongoDB (convert string to ObjectId for query)
        pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})

        if pet:
            return pet_helper(pet)
        else:
            raise HTTPException(status_code=404, detail="Pet not found")

    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is (don't convert to 500)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving pet: {str(e)}")


@app.put("/api/pets/{pet_id}", response_model=PetResponse)
async def update_pet(pet_id: str, pet: PetCreate):
    """
    Update an existing pet profile (full replacement).

    - Path parameter: pet_id
    - Request body: PetCreate schema with new data
    - Returns: The updated pet
    - Status: 200 OK, 404 if not found

    Note: PUT replaces all fields. For partial updates, use PATCH (not implemented).
    """
    try:
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Convert new data to dict
        pet_dict = pet.model_dump()

        # Update in MongoDB using $set operator
        # $set replaces only the specified fields (not the entire document)
        result = await pets_collection.update_one(
            {"_id": ObjectId(pet_id)},  # Filter: which document to update
            {"$set": pet_dict}           # Update: replace these fields
        )

        # Check if a document was found and updated
        if result.matched_count == 0:
            raise HTTPException(status_code=404, detail="Pet not found")

        # Fetch and return the updated document
        updated_pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})

        if updated_pet:
            return pet_helper(updated_pet)
        else:
            raise HTTPException(status_code=404, detail="Pet not found")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating pet: {str(e)}")


@app.delete("/api/pets/{pet_id}")
async def delete_pet(pet_id: str):
    """
    Delete a pet profile.

    - Path parameter: pet_id
    - Returns: Success message with deleted pet ID
    - Status: 200 OK, 404 if not found

    Note: No response_model because we return a custom message, not PetResponse.
    """
    try:
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        # Delete from MongoDB
        result = await pets_collection.delete_one({"_id": ObjectId(pet_id)})

        # Check if a document was actually deleted
        if result.deleted_count == 0:
            raise HTTPException(status_code=404, detail="Pet not found")

        return {"message": "Pet deleted successfully", "id": pet_id}

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting pet: {str(e)}")


# ============================================
# Product API Endpoints
# ============================================

# Products are read-only in this API (no create/update/delete).
# Products are imported via scrapers and import scripts, not the API.


@app.get("/api/products", response_model=List[ProductResponse])
async def get_all_products(
    life_stage: Optional[str] = None,
    breed_size: Optional[str] = None,
    grain_free: Optional[bool] = None,
    brand: Optional[str] = None,
    limit: Optional[int] = 100
):
    """
    Get all products with optional filtering.

    Query Parameters (all optional):
    - life_stage: "puppy", "adult", "senior", or "all"
    - breed_size: "small", "medium", "large", or "all"
    - grain_free: true or false
    - brand: Brand name (case-insensitive partial match)
    - limit: Max products to return (default 100)

    Example: GET /api/products?life_stage=adult&grain_free=true&limit=10

    The query is built dynamically based on which parameters are provided.
    """
    try:
        # Build MongoDB query dynamically
        query = {}

        if life_stage:
            query["life_stage"] = life_stage.lower()

        if breed_size:
            query["breed_size"] = breed_size.lower()

        # Note: Must check 'is not None' for booleans (False is a valid filter!)
        if grain_free is not None:
            query["grain_free"] = grain_free

        if brand:
            # $regex with $options:"i" = case-insensitive partial match
            # "orijen" matches "Orijen", "ORIJEN", etc.
            query["brand"] = {"$regex": brand, "$options": "i"}

        # Execute query with limit
        products = []
        async for product in products_collection.find(query).limit(limit):
            products.append(product_helper(product))

        return products

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving products: {str(e)}")


@app.get("/api/products/{product_id}", response_model=ProductResponse)
async def get_product_by_id(product_id: str):
    """
    Get a specific product by ID.

    - Path parameter: product_id (the product's unique string ID, NOT ObjectId)
    - Returns: The product if found
    - Status: 200 OK, 404 if not found

    Note: Product IDs are strings like "Orijen-Large-Breed-Adult", not ObjectIds.
    This is because products are imported with custom IDs, not auto-generated.
    """
    try:
        # Products use string IDs (not ObjectId), so query directly
        product = await products_collection.find_one({"_id": product_id})

        if product:
            return product_helper(product)
        else:
            raise HTTPException(status_code=404, detail="Product not found")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving product: {str(e)}")


# ============================================
# Recommendation Engine
# ============================================

# This is the "brain" of the Pet AI Assistant - it matches products to pets.
#
# How it works:
#   1. Take a pet profile (size, activity, goals, allergies)
#   2. Score every product in the database (0-100 points)
#   3. Filter out products with score < 50
#   4. Return top 15 matches with explanations
#
# Scoring breakdown (100 points max):
#   - Breed/Kibble Size Match:  0-20 points
#   - Activity + Weight Goal:   0-40 points (the most important factor)
#   - Nutritional Quality:      0-25 points
#   - Ingredient Quality:       0-10 points
#   - Price Value:              0-5  points (placeholder)
#
# Hard Filters (instant disqualification):
#   - Product contains pet's allergens → score = 0
#   - Kibble size incompatible with dog size → score = 0


class RecommendationResponse(BaseModel):
    """
    Response model for a single product recommendation.

    Fields:
    - product: Full product details (ProductResponse)
    - score: Compatibility score from 0-100
    - match_percentage: Same as score, as integer for display
    - reasons: List of human-readable explanations (e.g., "High protein for muscle building")
    """
    product: ProductResponse
    score: float
    match_percentage: int
    reasons: List[str]


# ----------------------------------------------
# Scoring Function 1: Breed Size (0-20 points)
# ----------------------------------------------

def calculate_breed_size_score(pet_breed_size: str, product_kibble_size: str) -> tuple[float, str]:
    """
    Calculate breed size compatibility score.

    Matching kibble size to dog size ensures:
    - Small dogs can chew comfortably
    - Large dogs don't choke on tiny pieces
    - Medium dogs get appropriately sized kibble

    Scoring Table:
    ┌─────────────┬───────────────┬────────────────┬───────────────┐
    │ Dog Size    │ Small Kibble  │ Regular Kibble │ Large Kibble  │
    ├─────────────┼───────────────┼────────────────┼───────────────┤
    │ Small       │ 20 pts (best) │ 15 pts (ok)    │ 0 pts         │
    │ Medium      │ 0 pts         │ 20 pts (best)  │ 0 pts         │
    │ Large       │ 0 pts         │ 15 pts (ok)    │ 20 pts (best) │
    └─────────────┴───────────────┴────────────────┴───────────────┘

    Returns:
        tuple[float, str]: (score, reason_text)
    """
    pet_size = pet_breed_size.lower()
    kibble = product_kibble_size.lower()

    if pet_size == "small":
        if kibble == "small":
            return 20.0, "Perfect kibble size for small breed"
        elif kibble == "regular":
            return 15.0, "Compatible kibble size"
        else:
            return 0.0, ""

    elif pet_size == "medium":
        if kibble == "regular":
            return 20.0, "Perfect kibble size for medium breed"
        else:
            return 0.0, ""

    elif pet_size == "large":
        if kibble == "large":
            return 20.0, "Perfect kibble size for large breed"
        elif kibble == "regular":
            return 15.0, "Compatible kibble size"
        else:
            return 0.0, ""

    return 10.0, ""  # Fallback for unknown sizes


# ----------------------------------------------
# Scoring Function 2: Activity + Goal (0-40 points)
# ----------------------------------------------

def calculate_activity_goal_score(
    activity_level: str,
    weight_goal: str,
    protein_pct: float,
    fat_pct: float,
    fiber_pct: float
) -> tuple[float, List[str]]:
    """
    Calculate score based on activity level and dietary goals.

    This is the MOST IMPORTANT scoring function (40 points max).
    It matches nutritional content to the dog's lifestyle and goals.

    Activity Levels: high, medium, low
    Weight Goals: muscle-gain, maintenance, weight-loss

    General Rules:
    - High activity + muscle-gain → Need HIGH protein (38%+) and HIGH fat (15%+)
    - High activity + maintenance → Need HIGH protein (35%+), MODERATE fat (12-18%)
    - Low activity + weight-loss → Need ADEQUATE protein, LOW fat (<12%), HIGH fiber (5%+)

    Returns:
        tuple[float, List[str]]: (score capped at 40, list of reasons)
    """
    score = 0.0
    reasons = []
    activity = activity_level.lower()
    goal = weight_goal.lower()

    # High Activity Dogs
    if activity == "high":
        if goal == "muscle-gain":
            # Need high protein AND high fat
            if protein_pct >= 38:
                score += 20
                reasons.append("Excellent protein for muscle building")
            elif protein_pct >= 35:
                score += 15
                reasons.append("Good protein for active dogs")

            if fat_pct >= 15:
                score += 20
                reasons.append("High energy from fat for active lifestyle")
            elif fat_pct >= 12:
                score += 10

        elif goal == "maintenance":
            # Need high protein, moderate fat
            if protein_pct >= 35:
                score += 20
                reasons.append("Great protein for active dogs")
            elif protein_pct >= 30:
                score += 15

            if 12 <= fat_pct <= 18:
                score += 20
                reasons.append("Balanced fat for maintenance")
            elif fat_pct >= 15:
                score += 15

        elif goal == "weight-loss":
            # High protein, lower fat
            if protein_pct >= 35:
                score += 20
                reasons.append("High protein helps maintain muscle during weight loss")

            if fat_pct < 12 and fiber_pct >= 5:
                score += 20
                reasons.append("Lower fat and good fiber for weight management")
            elif fat_pct < 15:
                score += 10

    # Medium Activity Dogs
    elif activity == "medium":
        if goal == "maintenance":
            if 30 <= protein_pct <= 38:
                score += 20
                reasons.append("Balanced protein for moderate activity")
            elif protein_pct >= 28:
                score += 15

            if 12 <= fat_pct <= 18:
                score += 20
                reasons.append("Balanced fat for maintenance")

        elif goal == "muscle-gain":
            if protein_pct >= 35:
                score += 20
                reasons.append("Good protein for muscle building")

            if fat_pct >= 15:
                score += 15
                reasons.append("Adequate fat for energy")

        elif goal == "weight-loss":
            if protein_pct >= 30:
                score += 15

            if fat_pct < 12:
                score += 20
                reasons.append("Lower fat supports weight loss")
            elif fat_pct < 15:
                score += 10

    # Low Activity Dogs
    elif activity == "low":
        if goal == "weight-loss":
            if protein_pct >= 28:
                score += 15
                reasons.append("Adequate protein for less active dogs")

            if fat_pct < 12 and fiber_pct >= 5:
                score += 25
                reasons.append("Perfect for weight loss - low fat, high fiber")
            elif fat_pct < 12:
                score += 15

        elif goal == "maintenance":
            if 28 <= protein_pct <= 35:
                score += 20
                reasons.append("Balanced nutrition for less active dogs")

            if 10 <= fat_pct <= 15:
                score += 20
                reasons.append("Moderate fat prevents weight gain")

        elif goal == "muscle-gain":
            # Less common for low activity, but still score
            if protein_pct >= 35:
                score += 15
            if fat_pct >= 12:
                score += 10

    # Cap at 40 points max (prevents overflow from multiple bonuses)
    return min(score, 40.0), reasons


# ----------------------------------------------
# Scoring Function 3: Nutritional Quality (0-25 points)
# ----------------------------------------------

def calculate_nutritional_quality_score(
    protein_pct: float,
    fat_pct: float,
    omega_3: Optional[float],
    dha: Optional[float],
    epa: Optional[float],
    grain_free: bool
) -> tuple[float, List[str]]:
    """
    Calculate nutritional quality score based on premium ingredients.

    This rewards high-quality nutrition regardless of the dog's specific needs.

    Point Breakdown:
    - Protein quality:  0-10 pts (38%+ = 10, 35%+ = 8, 30%+ = 5)
    - Omega-3 content:  0-3 pts  (0.8%+ = 3, 0.5%+ = 2)
    - DHA content:      0-2 pts  (0.3%+ = 2, 0.2%+ = 1)
    - Grain-free:       0-5 pts  (yes = 5)
    - Fat balance:      0-5 pts  (12-18% = 5, 10-20% = 3)

    Returns:
        tuple[float, List[str]]: (score capped at 25, list of reasons)
    """
    score = 0.0
    reasons = []

    # Protein quality (0-10 points)
    if protein_pct >= 38:
        score += 10
        reasons.append("Premium protein content")
    elif protein_pct >= 35:
        score += 8
        reasons.append("High protein content")
    elif protein_pct >= 30:
        score += 5

    # Omega-3/DHA/EPA for joints and brain (0-5 points)
    if omega_3 and omega_3 >= 0.8:
        score += 3
        reasons.append("Excellent Omega-3 for joints and coat")
    elif omega_3 and omega_3 >= 0.5:
        score += 2

    if dha and dha >= 0.3:
        score += 2
        reasons.append("Good DHA for brain health")
    elif dha and dha >= 0.2:
        score += 1

    # Grain-free (0-5 points)
    if grain_free:
        score += 5
        reasons.append("Grain-free formula")

    # Fat quality (0-5 points)
    if 12 <= fat_pct <= 18:
        score += 5
        reasons.append("Balanced fat content")
    elif 10 <= fat_pct <= 20:
        score += 3

    # Cap at 25 points max
    return min(score, 25.0), reasons


# ----------------------------------------------
# Scoring Function 4: Ingredient Quality (0-10 points)
# ----------------------------------------------

def calculate_ingredient_quality_score(ingredients: str, primary_proteins: str) -> tuple[float, List[str]]:
    """
    Calculate ingredient quality score based on ingredient list analysis.

    Checks for premium ingredient indicators:
    - Fresh meat first:      0-5 pts (looks for "fresh", "raw", "whole" in first 3 ingredients)
    - Multiple proteins:     0-3 pts (3+ sources = 3, 2 sources = 2)
    - No controversial:      0-2 pts (no "by-product", "meal", "digest", "artificial")

    Args:
        ingredients: Comma-separated ingredient list string
        primary_proteins: Comma-separated protein sources string

    Returns:
        tuple[float, List[str]]: (score capped at 10, list of reasons)
    """
    score = 0.0
    reasons = []

    ingredients_lower = ingredients.lower()

    # Fresh meat first ingredient (0-5 points)
    first_ingredients = ingredients_lower.split(',')[0:3]
    fresh_keywords = ['fresh', 'raw', 'whole']
    if any(keyword in ing for ing in first_ingredients for keyword in fresh_keywords):
        score += 5
        reasons.append("Fresh meat as primary ingredient")

    # Multiple protein sources (0-3 points)
    protein_count = len([p.strip() for p in primary_proteins.split(',') if p.strip()])
    if protein_count >= 3:
        score += 3
        reasons.append(f"Diverse protein sources ({protein_count} types)")
    elif protein_count >= 2:
        score += 2

    # No controversial ingredients (0-2 points)
    controversial = ['by-product', 'meal', 'digest', 'artificial']
    if not any(word in ingredients_lower for word in controversial):
        score += 2
        reasons.append("No controversial ingredients")

    # Cap at 10 points max
    return min(score, 10.0), reasons


# ----------------------------------------------
# Main Scoring Function: Orchestrates All Scores
# ----------------------------------------------

def score_product_for_pet(product: dict, pet_profile: dict) -> tuple[float, List[str]]:
    """
    Calculate overall compatibility score for a product given a pet profile.

    This is the main orchestrator that:
    1. Applies HARD FILTERS (allergies, kibble size) - returns 0 if failed
    2. Calls all 4 scoring functions
    3. Adds up total score (max 100 points)
    4. Returns score and list of reasons

    Args:
        product: MongoDB product document (dict)
        pet_profile: Pet profile with keys: breedSize, activityLevel, weightGoal, allergies

    Returns:
        tuple[float, List[str]]: (total_score 0-100, list of reason strings)
    """
    total_score = 0.0
    all_reasons = []

    # --- Extract pet info from profile ---
    pet_breed_size = pet_profile.get("breedSize", "medium")
    pet_activity = pet_profile.get("activityLevel", "medium")
    pet_goal = pet_profile.get("weightGoal", "maintenance")
    # Convert allergies to lowercase for case-insensitive matching
    pet_allergies = [a.lower().strip() for a in pet_profile.get("allergies", [])]

    # --- Extract product info from MongoDB document ---
    product_kibble = product.get("kibble_size", "regular")
    protein_pct = product.get("protein_pct") or 0      # Use 0 if None
    fat_pct = product.get("fat_pct") or 0
    fiber_pct = product.get("fiber_pct") or 0
    omega_3 = product.get("omega_3_fatty_acids")       # Keep as None if missing
    dha = product.get("DHA")
    epa = product.get("EPA")
    grain_free = product.get("grain_free", False)
    ingredients = product.get("ingredients", "")
    primary_proteins = product.get("primary_proteins", "")
    allergen_tags = product.get("allergen_tags", "")
    price_per_kg = product.get("price_per_kg")

    # ==========================================
    # HARD FILTERS - Instant Disqualification
    # ==========================================
    # These return 0 immediately. A product with allergens is dangerous
    # no matter how good its nutrition is.

    # Hard Filter 1: Allergy check
    # Split allergen_tags string into list: "chicken,beef" → ["chicken", "beef"]
    product_allergens = [a.lower().strip() for a in allergen_tags.split(',') if a.strip()]
    # Check if ANY pet allergy matches ANY product allergen
    if any(allergy in product_allergens for allergy in pet_allergies):
        return 0.0, ["Contains allergens - NOT RECOMMENDED"]

    # Hard Filter 2: Kibble size incompatibility
    pet_size = pet_breed_size.lower()
    kibble = product_kibble.lower()

    # Small dogs cannot eat large kibble (too hard to chew)
    if pet_size == "small" and kibble == "large":
        return 0.0, ["Kibble too large for small breed"]

    # Large dogs should not eat small kibble (choking hazard, not satisfying)
    if pet_size == "large" and kibble == "small":
        return 0.0, ["Kibble too small for large breed"]

    # Medium dogs need regular kibble
    if pet_size == "medium" and kibble in ["small", "large"]:
        return 0.0, ["Kibble size not suitable for medium breed"]

    # ==========================================
    # SOFT SCORING - Add points for good matches
    # ==========================================
    # Products that pass hard filters get scored on quality/fit.

    # Score 1: Breed Size Match (0-20 points)
    breed_score, breed_reason = calculate_breed_size_score(pet_breed_size, product_kibble)
    total_score += breed_score
    if breed_reason:
        all_reasons.append(breed_reason)

    # Score 2: Activity + Weight Goal Match (0-40 points) - Most Important!
    activity_score, activity_reasons = calculate_activity_goal_score(
        pet_activity, pet_goal, protein_pct, fat_pct, fiber_pct
    )
    total_score += activity_score
    all_reasons.extend(activity_reasons)  # extend() adds all items from list

    # Score 3: Nutritional Quality (0-25 points)
    nutrition_score, nutrition_reasons = calculate_nutritional_quality_score(
        protein_pct, fat_pct, omega_3, dha, epa, grain_free
    )
    total_score += nutrition_score
    all_reasons.extend(nutrition_reasons)

    # Score 4: Ingredient Quality (0-10 points)
    ingredient_score, ingredient_reasons = calculate_ingredient_quality_score(
        ingredients, primary_proteins
    )
    total_score += ingredient_score
    all_reasons.extend(ingredient_reasons)

    # Score 5: Price Value (0-5 points)
    price_score = 0.0
    if price_per_kg and price_per_kg > 0:
        quality_points = nutrition_score + ingredient_score
        value_ratio = quality_points / price_per_kg

        if value_ratio >= 3.0:
            price_score = 5.0
            all_reasons.append("Excellent value for the quality")
        elif value_ratio >= 2.2:
            price_score = 4.0
            all_reasons.append("Good price for high quality")
        elif value_ratio >= 1.5:
            price_score = 3.0
        elif value_ratio >= 1.0:
            price_score = 2.0
        else:
            price_score = 1.0
    else:
        price_score = 2.5  # Neutral score when pricing info is missing

    total_score += price_score

    return total_score, all_reasons


# ----------------------------------------------
# Recommendation API Endpoint
# ----------------------------------------------

@app.get("/api/recommendations/{pet_id}")
async def get_recommendations(pet_id: str):
    """
    Get personalized dog food recommendations for a specific pet.

    This is the main endpoint that powers the recommendation feature!

    URL: GET /api/recommendations/507f1f77bcf86cd799439011

    Flow:
    1. Fetch pet profile from database
    2. Query products with hard filters (dry food, matching life stage)
    3. Score each product using score_product_for_pet()
    4. Filter to products with score >= 50
    5. Sort by score (highest first)
    6. Return top 15 recommendations

    Response:
    {
        "pet": { pet profile },
        "total_matches": 42,
        "recommendations": [
            { "product": {...}, "score": 87.5, "match_percentage": 87, "reasons": [...] },
            ...
        ]
    }
    """
    try:
        # Step 1: Validate and fetch pet profile
        if not ObjectId.is_valid(pet_id):
            raise HTTPException(status_code=400, detail="Invalid pet ID format")

        pet = await pets_collection.find_one({"_id": ObjectId(pet_id)})
        if not pet:
            raise HTTPException(status_code=404, detail="Pet not found")

        # Build pet profile dict for scoring functions
        pet_profile = {
            "ageGroup": pet.get("ageGroup", "adult"),
            "breedSize": pet.get("breedSize", "medium"),
            "activityLevel": pet.get("activityLevel", "medium"),
            "weightGoal": pet.get("weightGoal", "maintenance"),
            "allergies": pet.get("allergies", [])
        }

        # Step 2: Query products with database-level hard filters
        # These filters run in MongoDB (fast) before we score in Python
        query = {
            "format": "dry",  # Only dry food (wet food not yet supported)
        }

        # Life stage must match pet's age OR be "all life stages"
        # MongoDB $or operator: matches if ANY condition is true
        pet_age = pet_profile["ageGroup"].lower()
        query["$or"] = [
            {"life_stage": pet_age},      # e.g., "puppy", "adult", "senior"
            {"life_stage": "all"}          # Products for all life stages
        ]

        # Fetch all matching products
        all_products = []
        async for product in products_collection.find(query):
            all_products.append(product)

        # Handle case where no products match basic criteria
        if not all_products:
            return {
                "pet": pet_profile,
                "recommendations": [],
                "message": "No products found matching basic criteria"
            }

        # Step 3: Score each product using our scoring algorithm
        scored_products = []
        for product in all_products:
            score, reasons = score_product_for_pet(product, pet_profile)

            # Only include products with score >= 50 (decent match)
            if score >= 50:
                scored_products.append({
                    "product": product_helper(product),
                    "score": round(score, 1),           # Round to 1 decimal
                    "match_percentage": int(score),      # Integer for display
                    "reasons": reasons[:3]               # Show top 3 reasons only
                })

        # Step 4: Sort by score (highest first) and limit to top 15
        # lambda x: x["score"] means "sort by the 'score' field"
        # reverse=True means descending order (highest first)
        scored_products.sort(key=lambda x: x["score"], reverse=True)
        top_recommendations = scored_products[:15]  # Slice first 15

        return {
            "pet": pet_profile,
            "total_matches": len(scored_products),      # How many products scored 50+
            "recommendations": top_recommendations       # Top 15 products
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating recommendations: {str(e)}")


# ============================================
# Application Lifecycle Events
# ============================================

# FastAPI provides hooks for startup/shutdown events.
# Use these to initialize resources (DB connections, caches) on startup
# and clean them up (close connections) on shutdown.


@app.on_event("startup")
async def startup_event():
    """
    Runs automatically when the server starts.

    Use for:
    - Database connection verification
    - Cache warming
    - Logging startup info
    """
    print("Pet AI Assistant API starting up...")
    print(f"Connected to MongoDB: {MONGODB_URL}")
    print(f"Database: {DATABASE_NAME}")
    print("Ready to accept requests!")


@app.on_event("shutdown")
async def shutdown_event():
    """
    Runs automatically when the server stops.

    Use for:
    - Closing database connections
    - Flushing caches
    - Cleanup tasks
    """
    print("Shutting down Pet AI Assistant API...")
    client.close()  # Close MongoDB connection properly
    print("MongoDB connection closed")


# ============================================
# How to Run This Server
# ============================================
# Command: uvicorn main:app --reload --port 8080
#
# Breakdown:
#   uvicorn     = ASGI server (runs async Python web apps)
#   main        = this file (main.py)
#   app         = the FastAPI instance (line 25)
#   --reload    = auto-restart when code changes (dev only!)
#   --port 8080 = listen on port 8080
#
# After running, visit:
#   http://localhost:8080/docs  → Interactive API documentation
#   http://localhost:8080/      → Health check endpoint
# ============================================
